**正当你在会议室里坐立不安，不知道这次会遇到什么面试官。**

**一道光顺着门缝折射进来，亮瞎了你的钛合金狗眼。**

**面试官看着你浓郁的发量和正襟危坐的姿势，不禁唏嘘一声，怕又是一个水货。**



**面试官，你好，我是大帅比，你很客气的对着面试官打招呼，希望能有一个好印象**

**面试官淡淡看你一眼（默念浪费半小时），你好，请坐**



**那我们正式开始吧，你说说JDK1.8对HashMap有哪些比较大的改动吗，面试官平淡的说道。**

- JDB1.8采用数组+链表+红黑树结构，之前一直都是数组+链表的结构
- 链表新节点采用尾插法，避免JDK1.7使用头插法出现的死循环，导致CPU用满
- resize()扩容时优化不再需要重新hash计算



**面试官轻轻的点了点头，那知道为什么要增加红黑树结构吗？**

主要是为了防止极端情况下，hash冲突严重时的查询性能。

比如HashMap的容量为16，现在有10个数据且hash相同。

数组+链接结构 就会形成数组一个节点的单链表形式

链表查询的时间复杂度是o(n)

红黑树查询的时间复杂度为o(logn)



**面试官偷偷撇了你一眼，那红黑树和链表是怎样互相转化的呢？**

**插入：**默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长

度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）。

而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。

**移除：**当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节

点转链表节点（untreeify）。



**为什么阈值要设置为8呢？**

因为这是一种时间和空间上的妥协：

- 红黑树节点占用空间大小约为链表的两倍大小，当节点过小时，红黑树查询优势不大，用两倍的空间换取微小的查询速度并不划算，而且红黑树添加新的节点需要左旋和右旋，也浪费性能。
- 根据HashMap源码注释，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中节点个数为8时的概率为 0.00000006，冲突概率很小，并且8节点时红黑树的优势比较明显。



**面试官认真的看了你下，心想，小家伙懂得还挺多啊，加大点力度。**



**HashMap有哪些常用的属性和默认值吗？**

**重要属性**：

1. size：HashMap 已经存储的节点个数；
2. threshold：扩容阈值，当 HashMap 的个数达到该值，触发扩容。
3. loadFactor：负载因子，扩容阈值 = 容量 * 负载因子

**属性默认值：**

1. 默认初始容量为16
2. 默认扩容因子是0.75
3. 默认扩容倍数为2倍



**按照你的说法扩容阈值是0.75，那么如果我设置初始容量为11，那11*0.75岂不是带有小数，这怎么计算，能详细说说吗？（看你怎么给自己填坑）**

HashMap默认容量是16，并且容量必须为2的N次方。

当我们初始设置容量时，HashMap会通过`tableSizeFor()`方法将我们设置的值找一个最近的2的N次方作为容量。

例如我们设置初始容量为11，那经过计算就变成16了，阈值计算是threshold=16*0.75=12。

具体的代码计算就是下面的这个：

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```



**面试官认真的看了下你，嘴角漏出欣慰的微笑，今天还有点惊喜啊。**



**为什么初始容量设置为0.75，有什么讲究吗？**



这个也是在时间和空间上权衡的结果：

- 如果值较高，数组得到充分的利用，但是hash 冲突的概率会增大，增加查找成本。

- 如果值较低，hash 冲突会降低，但是有较多的数组空间会被浪费。当达到阈值就会扩容，导致较多的数组没有保存节点数据。

所以折衷考虑 0.75 似乎是一个合理的值。



**说到扩容，JDK1.8HashMap扩容具体是怎么优化的，为什么不需要重新hash计算？**

**获取节点位置：**

首先HashMap进行选取数组节点时使用`（n-1）& hash`获得节点位置

**扩容前**：

例如 容量16 hash值为 0110

```
(n-1) & 10110

    0  1 1 1 1

&   1  0 1 1 0

------------------

    0  0 1 1 0
```

00110也就是第6位

**扩容后：**

此时我们扩容后容量是32位

```
(n-1) & 10110

     1  1 1 1 1

&    1  0 1 1 0

------------------------

     1  0 1 1 0
```

10110 = 00110+10000 = 6+15=23



**结果：**

我们可以看出HashMap扩容后，位置是否改变取决于hash的高位是不是为1

**判断方法：**`(e.hash & oldCap) == 0`

- 为真：高位是0
- 为假：高位为1

**计算位置：**

- 如果为1
  新位置 =  原位置+原容量
- 如果为0
  新位置 =  原位置



**今天就到这吧，小伙子，很高兴加入我们。**

![u=3742199653,1935850630&fm=26&gp=0](https://gitee.com/tworan/typora-img/raw/master/imgs/u=3742199653,1935850630&fm=26&gp=0.jpg)